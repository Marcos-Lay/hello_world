# 面试心得
## 1.hashset和treeset的区别
- HashSet与TreeSet接口的一点不同，HashSet  保存的数据是无序的，TreeSet保存的数据是有序的，所以如果要想保存的数据有序应该使用TreeSet子类。
- 利用TreeSet保存自定义类对象的时候，自定义所在的类一定要实现Comparable接口，如果没有实现这个接口那么就无法区分大小关系，而且在TreeSet中如果要进行排序，那么就要将所有的字段都进行比较，就是说在TreeSet中是依靠comparato()方法返回的是不是0来判断是不是重复元素的。
- 如果是HashSet子类，那么其判断重复数据的方式不是依靠的comparable接口而是Object类之中的两个方法：(1)取得对象的哈希码 hashCode（）；(2)对象比较：equals（）； 这俩个方法均不需要自己编写，在eclipse里面可以使用右键source 选择自动生成。就像生成Getter 和Setter 方法一样。
- 总结：TreeSet 依靠的是Comparable 来区分重复数据；
HashSet 依靠的是hashCode()、equals()来区分重复数据
Set 里面不允许保存重复数据。
## 2.乐观锁和悲观锁
### 悲观锁
- 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
### 乐观锁
- 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
## 3.单例模式中懒汉和饿汉
### 单件模式用途：
- 单件模式属于工厂模式的特例，只是它不需要输入参数并且始终返回同一对象的引用。单件模式能够保证某一类型对象在系统中的唯一性，即某类在系统中只有一个实例。它的用途十分广泛，打个比方，我们开发了一个简单的留言板，用户的每一次留言都要将留言信息写入到数据库中，最直观的方法是没次写入都建立一个数据库的链接。这是个简单的方法，在不考虑并发的时候这也是个不错的选择。但实际上，一个网站是并发的，并且有可能是存在大量并发操作的。如果我们对每次写入都创建一个数据库连接，那么很容易的系统会出现瓶颈，系统的精力将会很多的放在维护链接上而非直接查询操作上。这显然是不可取的。
如果我们能够保证系统中自始至终只有唯一一个数据库连接对象，显然我们会节省很多内存开销和cpu利用率。这就是单件模式的用途。当然单件模式不仅仅只用于这样的情况。在《设计模式：可复用面向对象软件的基础》一书中对单件模式的适用性有如下描述：
1、当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
2、当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

### 下面对单件模式的懒汉式与饿汉式进行简单介绍：
- 1、饿汉式：在程序启动或单件模式类被加载的时候，单件模式实例就已经被创建。
- 2、懒汉式：当程序第一次访问单件模式实例时才进行创建。
如何选择：如果单件模式实例在系统中经常会被用到，饿汉式是一个不错的选择。反之如果单件模式在系统中会很少用到或者几乎不会用到，那么懒汉式是一个不错的选择。
## 4.mybatis的优点
- 一、MyBatis框架的优点：  
　　1. 与JDBC相比，减少了50%以上的代码量。  
　　2. MyBatis是最简单的持久化框架，小巧并且简单易学。  
　　3. MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用。  
　　4. 提供XML标签，支持编写动态SQL语句（XML中使用if, else）。  
　　5. 提供映射标签，支持对象与数据库的ORM字段关系映射（在XML中配置映射关系，也可以使用注解）。
- 二、MyBatis框架的缺点：  
　　1. SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。  
　　2. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
## 5.springmvc的全过程
## 6.事务的隔离级别
- default：默认隔离级别，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用"select @@tx_isolation"来查看默认的事务隔离级别
- read_uncommitted：读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用
- read_committed：读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读
- repeatable_read：重复读取，即在数据读出来之后加锁，类似"select * from XXX for update"，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决
- serlalizAble：串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了
## 7.实务的传播机制
- propagation_required：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
- propagation_supports：支持当前事务，如果当前没有事务，就以非事务方式执行。
- propagation_mandatory：使用当前的事务，如果当前没有事务，就抛出异常。
- propagation_requires_new：新建事务，如果当前存在事务，把当前事务挂起。
- propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- propagation_never：以非事务方式执行，如果当前存在事务，则抛出异常。
- propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。
## 8.怎么避免死锁
### 一、什么是死锁
- 死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。例如，在某一个计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。
### 二、死锁产生的原因
- 系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
- 进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。
### 三、死锁的四个必要条件
- 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
- 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
- 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
### 四、 死锁的避免与预防
#### 死锁避免的基本思想：
- 系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 
如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。
#### 死锁预防：我们可以通过破坏死锁产生的4个必要条件来预防死锁
- 由于资源互斥是资源使用的固有特性是无法改变的。
- 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
- 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。
- 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。



