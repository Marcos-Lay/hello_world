# 深入理解JVM虚拟机心得  
## JVM的运行时数据区  
*线程私有：随线程而生且随线程而灭。*
- **方法区/永久代（线程共享）**  
1.方法区存放编译器编译后的代码。（已被虚拟机加载的类信息，常亮，静态变量）。  
2.方法去的垃圾回收比较少的出现，回收主要是对常量池的回收和对类型的卸载。  
3.当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。  
4.运行时常量池是方法区的一部分。 

- **虚拟机栈（线程私有）**  
1.生命周期与线程相同。  
2.每一个方法被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  
3.栈指的就是虚拟机栈，也可以说是虚拟机栈中的程序变量表部分。  
4.局部变量表中存放了各种数据类型和对象引用。64位长度的long和double会占用2个局部变量空间，其余的占用一个。  
5.线程请求的栈深度大于虚拟机允许的深度抛出StackOverflowError异常。  
6.虚拟机栈无法扩展到足够的内存会抛出OutOfMemoryError异常。

- **本地方法栈**  
1.HotSpot把本地方法栈与虚拟机栈合二为一。  
2.本地方法栈与虚拟机栈最大的区别就是本地方法栈为Native方法服务，虚拟机栈为java方法服务。

- **堆（线程共享）**  
1.java堆是java虚拟机管理的内存最大的一部分。  
2.堆中的唯一目的就是存放对象实例。  
3.堆可以处于物理上不连续的内存空间中。   
4.如果堆中没有内存完成实例分配，并且当堆也无法扩展时，将会抛出OutOfMemoryError异常。 

- **程序计数器（线程私有）**  
1.不会产生OutOfMemoryError情况。  
2.每条线程都会有一个独立的程序计数器。  
3.选择下一步的字节码指令，也就是选择要执行指令的行号。  
4.如果正在执行的是Native 方法，则这个技术器值为空（Undefined）

## Object obj = new Object（）  
Object obj 在栈中，new Object（）在堆中，查找堆中的对象的地址存储在方法区中。对象的访问有两种主流的方式：使用句柄和直接指针。

## OutOfMemoryError异常  
1.除了程序计数器，虚拟机内存的其他几个运行时区域都会抛出这个异常。  

## Java堆溢出  
1.会出现堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“java heap space”。

## 垃圾收集器与内存分配策略
### 引用计数算法  
- 判断对象是否存活：给对象中添加一个引用计数器，每当有一个地方应用它时，计数器就加1；当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不能再被使用的。垃圾回收机制就会回收这对象所占用的内存。  
- java语言（虚拟机）内没有使用引用计数算法来管理内存，它难以解决对象之间相互循环引用的问题。
### 根搜索算法  
- Java和C#都是通过根搜索算法来判断对象是否可以回收的。
### 引用
- 强引用  
Object obj = new Object（）既是一个强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。
- 软引用  
在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中并进行第二次回收。如果第二次回收还是没有足够的空间，才会抛出内存溢出异常。
- 弱引用  
被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
- 虚引用  
为一个对象设置虚引用的唯一目的就是希望能在这个对象被回收时收到一个系统通知。
### 回收方法区
- 在大量使用反射，动态代理，CGLib的场景中，以及动态生成JSP和OSGi这类场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。
### 垃圾收集算法
- 新生代的回收采用复制算法
- 老年代的回收采用标记清除/标记整理算法
### 内存分配与回收策略
#### 新生代分为Eden和Survivor两部分，Eden是复制算法中复制的一部分，Survivor是粘贴的一部分。
- 大多数情况下，对象在新生代中分配，当新生代没有足够的空间进行分配是，虚拟机将发起一次MinorGC。
- 大对象（长字符串和数组）直接进入老年代
- MinorGC15次（默认）后还没有被清除的对象将进入到老年代中，这个次数可以通过参数-XX:MaxTenuringThreshold来设置。
- 当Survivor空间中相同年龄的对象大小的总和大于Survivor空间的一半，那么年龄大于或等于该年龄的对象可以直接进入老年代，无需等到参数要求的值。
## 虚拟机类加载机制
### 类加载的生命周期  
- 加载；验证；准备；解析；初始化；使用和卸载。
### 对类立即进行初始化
- 遇到new，getstatic，putstatic，invokestatic这四条字节码指令时。
- 使用java.long.reflect包的方法对类进行发射调用的时候。
- 当初始化一个类时，如果父类还没有初始化，需要先对其父类进行初始化。
- 当虚拟机启动时，包含main方法的类会先被初始化。
### 双亲委派模型
- 除了顶层的启动类加载器，其余的类加载器都应当有自己的父类加载器。
- 类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合的方式。





